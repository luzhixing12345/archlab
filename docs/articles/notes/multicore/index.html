<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/python.css /><link rel='stylesheet' href=../../../css/riscvasm.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/txt.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/archlab.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">multicore</a><ul><li><a href="#h2-1">动机</a><ul><li><a href="#h3-2">摩尔定律失效</a></li></ul><ul><li><a href="#h3-3">性能问题</a></li></ul></li></ul><ul><li><a href="#h2-4">并行计算</a></li></ul><ul><li><a href="#h2-5">多处理器体系结构</a><ul><li><a href="#h3-6">UMA</a></li></ul><ul><li><a href="#h3-7">NUMA</a></li></ul><ul><li><a href="#h3-8">指令和数据</a></li></ul></li></ul><ul><li><a href="#h2-9">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">multicore</h1><h2 id="h2-1">动机</h2><h3 id="h3-2">摩尔定律失效</h3><p>现代计算机实现技术的基础核心是以晶体管为基本单元的平面集成电路.1965年,摩尔(GordonMoore)在Electronics上撰文,认为集成电路密度大约每两年翻一番,这就是著名的摩尔定律.40多年来,摩尔定律不但印证了集成电路技术的发展,也印证了计算机技术的发展. 下图展示了内存芯片和Intel微处理器的发展变化.</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121161124.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121161124.png" alt="20240121161124"></a></p><p>指数式增长速度是非常可怕的, 因此摩尔定律是不可能永远或者长期无限发展下去的,这个定律能维持50余年,已经堪称集成电路设计制造人员创造的奇迹.</p><p>但目前时钟频率锁定在 3GHz,</p><p>近些年摩尔定律的速度已经放缓了,很多人声称摩尔定律已经失效、集成电路进入后摩尔时代,但芯片设计制造人员一直在不断改进设计与制造工艺为摩尔定律续命. 未来CPU的发展趋势应该是降低功耗、优化性能设计、提高功效等,而不是单纯的堆叠晶体管数量.</p><h3 id="h3-3">性能问题</h3><ul><li>功耗墙</li></ul><ul><li>ILP墙</li></ul><ul><li>内存墙</li></ul><p>-&gt; 在晶体管数量无法提升的情况下如何提高性能 =&gt; 多核</p><h2 id="h2-4">并行计算</h2><p>Definition: &quot;A parallel computer is a collection of processing elements that <b>cooperate and communicate</b> to solve large problemsfast.&quot;</p><blockquote><p>&quot;并行计算机是处理元件的集合,它们通过<b>合作和通信</b>快速解决大型问题.</p></blockquote><p>Parallel architecture = <b>computing</b> model + <b>communication</b> model</p><p>在处理并行任务中, 计算和通信都是很重要的环节, 其中我们重点关注多处理器的通信部分. 通信模型分为两种:</p><ul><li>共享地址: 通过 load/store 通信, 需要显式同步, 因为接收核心需要知道存储何时发生</li></ul><ul><li>消息传送: 通过消息通信, 隐式同步, 因为传输消息的时候就已经完成了同步</li></ul><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121114050.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121114050.png" alt="20240121114050"></a></p><p>下文我们重点看一下共享地址的多处理器体系结构的情况</p><h2 id="h2-5">多处理器体系结构</h2><p>提高硬件性能最简单,最便宜的方法之一是在主板上放置多个 CPU.这可以通过让不同的 CPU 承担不同的作业(非对称多处理)或让它们全部并行运行来完成相同的作业(对称多处理,又名 SMP)来完成.有效地进行非对称多处理需要有关计算机应执行的任务的专业知识,而这在 Linux 等通用操作系统中是不可用的.另一方面,对称多处理相对容易实现.</p><blockquote><p>相对容易但并不是真的很容易.在对称多处理环境中,CPU 共享相同的内存,因此在一个 CPU 中运行的代码可能会影响另一个 CPU 使用的内存.无法再确定在上一行中设置为某个值的变量仍然具有该值;显然,这样的编程是不可能的.</p></blockquote><p>在共享内存地址又分为两种模式, SMP 和 DSM</p><ul><li><b>SMP</b>(Symmetrical Multi-Processing): 即对称多处理技术,是指将<b>多CPU汇集在同一总线上,各CPU间进行内存和总线共享的技术</b>.将同一个工作平衡地(run in parallel)分布到多个CPU上运行,该相同任务在不同CPU上共享着相同的物理内存; 其内存组织是<b>集中式</b>的; 内存访问模型是均匀的, 称为 <b>UMA</b>(uniform memory access)</li></ul><ul><li><b>DSM</b>(distribute share memory): 即分布式共享存储器, 将存储器分散在节点之间, 各节点的 CPU 有本地的内存和远端内存, 访问时间不均匀; 其内存组织形式是<b>分布式</b>的; 内存访问模型是不均匀的, 称为 <b>NUMA</b>(non-uniform memory access)</li></ul><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121120723.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121120723.png" alt="20240121120723"></a></p><h3 id="h3-6">UMA</h3><p>Uniform Memory Access,简称UMA, 即均匀存储器存取模型.<b>所有处理器对所有内存有相等的访问时间</b></p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119232539.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119232539.png" alt="20240119232539"></a></p><p>既然要连接多个 CPU 和内存, 这种 UMA 的方式很明显是最简单直接的, 每个 CPU 访问内存的时间是相同的, 整个模型是完全对称的; 但问题也同样明显, <b>BUS 会成为性能的杀手</b>. <b>多个 CPU 需要平分总线的带宽, 这显然非常不利于计算</b>.</p><p>x86多处理器发展历史上,早期的多核和多处理器系统都是UMA架构的.这种架构下, 多个CPU通过同一个北桥(North Bridge)芯片与内存链接.北桥芯片里集成了内存控制器(Memory Controller),</p><p>下图是一个典型的早期 x86 UMA 系统,四路处理器通过 FSB (前端系统总线, Front Side Bus) 和主板上的内存控制器芯片 (MCH, Memory Controller Hub) 相连, CPU 通过 PCH 访问内存, DRAM 是以 UMA 方式组织的,延迟并无访问差异.</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/numa-fsb-3.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/numa-fsb-3.png" alt="image"></a></p><h3 id="h3-7">NUMA</h3><p>基于总线的计算机系统有一个瓶颈, 有限的带宽会导致可伸缩性问题.系统中添加的CPU越多,每个节点可用的带宽就越少.此外,添加的CPU越多,总线就越长, 延迟也就越高.</p><p>因此在另一种设计方法中, 多处理器采用物理分布式存储器, 为了支持更多的处理器, 存储器必须分散在处理器之间, 而不应当是集中式的;</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240120202032.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240120202032.png" alt="20240120202032"></a></p><p>将存储器分散在节点之间, 既增加了带宽, 也缩短了到本地存储器的延迟. DSM 多处理器也被称为 NUMA(非一致存储器访问), 这是因为它的<b>访问时间取决于数据字在存储器的位置.</b> DSM 的关键缺点是处理器之间传送数据的过程变得复杂了一些, 需要在软件中多花一些力气, 以充分利用分布式存储器提升的存储器带宽.</p><p>与UMA不同的是,<b>在NUMA中每个处理器有属于自己的本地物理内存(local memory),对于其他CPU来说是远程物理内存(remote memory)</b>.一般而言,访问本地物理内存由于路径更短,其访存时间要更短.</p><p>在 SMP(对称多处理技术) 和 DSM(分布式共享存储器) 这两种体系结构中, <b>线程之间的通信是通过共享地址空间完成的, 存储器的地址统一编码, 任何一个拥有正确寻址权限的处理器都可以向任意存储器位置发出存储器引用</b>. 共享存储器的含义就是指共享地址空间.</p><h3 id="h3-8">指令和数据</h3><p>单指令多数据 SIMD 和多指令多数据 MIMD</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121114417.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121114417.png" alt="20240121114417"></a></p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121114511.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240121114511.png" alt="20240121114511"></a></p><h2 id="h2-9">参考</h2><ul><li><a href="https://www.163.com/dy/article/FLPKHUFL0511FQO9.html" target="_blank">仙童半导体和&quot;八叛逆&quot;所缔造的硅谷模式</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../code/python-riscv" >code</a><ul><li><a href="../../code/python-riscv" >python-riscv</a></li></ul><ul><li><a href="../../code/processor-controllor" >processor-controllor</a></li></ul><ul><li><a href="../../code/pipeline-profiling" >pipeline-profiling</a></li></ul><ul><li><a href="../../code/scoreboard" >scoreboard</a></li></ul><ul><li><a href="../../code/Tomasulo" >Tomasulo</a></li></ul><ul><li><a href="../../code/rob-tom" >rob-tom</a></li></ul><ul><li><a href="../../code/superscale" >superscale</a></li></ul></li></ul><ul><li><a href="../../notes/multicore" >notes</a><ul><li><a href="../../notes/multicore" >multicore</a></li></ul><ul><li><a href="../../notes/cache" >cache</a></li></ul><ul><li><a href="../../notes/cache-coherance" >cache-coherance</a></li></ul></li></ul><ul><li><a href="../../read/lecture1" >read</a><ul><li><a href="../../read/lecture1" >lecture1</a></li></ul><ul><li><a href="../../read/lecture2" >lecture2</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../code/superscale","../../notes/cache","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>