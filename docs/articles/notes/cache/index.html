<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/python.css /><link rel='stylesheet' href=../../../css/riscvasm.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/txt.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/archlab.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">cache</a><ul><li><a href="#h2-1">缓存组织结构</a></li></ul><ul><li><a href="#h2-2">直接映射高速缓存</a></li></ul><ul><li><a href="#h2-3">组相联高速缓存</a></li></ul><ul><li><a href="#h2-4">全相联高速缓存</a></li></ul><ul><li><a href="#h2-5">高速缓存的写</a></li></ul><ul><li><a href="#h2-6">真实的高速缓存层次</a></li></ul><ul><li><a href="#h2-7">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">cache</h1><p>众所周知,不同存储技术的访问时间差异很大,速度较快的技术每字节成本要比速度较慢的技术高,而且容量小.</p><p>下图是一个经典的计算机存储器结构层次,高层向底层走存储设备变得更慢,更便宜和更大.</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228203220.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228203220.png" alt="image"></a></p><p>早期计算机系统的存储器层次只有三层,CPU寄存器,DRAM主存储器,磁盘存储.由于CPU和主存之间的频率逐渐增大,系统设计者被迫在CPU寄存器文件和主存之间插入了一个小的SRAM高速缓存,被称为L1高速缓存(一级缓存),如下图所示.L1高速缓存的访问速度几乎和寄存器一样快,典型的是4个时钟周期.</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228203645.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228203645.png" alt="image"></a></p><h2 id="h2-1">缓存组织结构</h2><p>一般而言,高速缓存的结构可以用元组(S,E,B,m)来描述, S指一共有S个高速缓存组,每组E行,每一行中有效的缓存块的个数为B, m为主存物理地址长度(通常为64). 组织结构如下图所示:</p><blockquote><p>每一个缓存块的大小都是 1 byte, 缓存块的个数 B 和 S 都是 2 的幂次, 即 <code>S = 2^s</code>, <code>B = 2^b</code>.</p></blockquote><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119110922.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119110922.png" alt="20240119110922"></a></p><p>缓存总大小为 <code>B x E x S</code> 字节, 即图中灰色部分.</p><p>每一个缓存行除了缓存块还有 1 位有效位, 用于表示这个行是否包含有意义的信息; 以及 t 位标记位.</p><p>对于一个虚拟地址, 其在缓存中的地址会被划分成如下格式.</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119114604.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119114604.png" alt="20240119114604"></a></p><p>高速缓存一共S组,<b>一共需要s位(2^s=S)来对应每一组</b>, 每一行是一个高速缓存行.其中每一行有1位有效位,t位标记位,和B字节的缓存块大小, 因为计算机的地址长度m是确定的(一般32或者64),<b>B字节大小的缓存块需要b位的偏移量来表示(2^b=B)</b>, 这里的t是计算出来的, 组索引占用s位, 每一个缓存块索引占 b 位, 所以 <code>t = m-b-s</code>, 即<b>剩余部分都留作 tag 位</b></p><p>高速缓存可以被分为不同的类:</p><ul><li>直接映射高速缓存</li></ul><ul><li>组相联高速缓存</li></ul><ul><li>全相联高速缓存</li></ul><p>下面我们分别讨论一下</p><h2 id="h2-2">直接映射高速缓存</h2><p>每个组只有一行(E=1)的高速缓存被称为直接映射高速缓存,这种情况是最容易实现和理解的</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228220428.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228220428.png" alt="image"></a></p><p>现在一条加载指令指示CPU从主存地址A中读取一个字,那么此时<b>高速缓存如何判断此时缓存中是否保存着A地址处那个字的副本呢?</b></p><p>这个过程被分为三个部分: 组选择 + 行匹配 + 字选择</p><ol start="1"><li>组选择<p>给定地址A,我们可以根据之前计算的t,s,b的数据截取其中s的部分,这是<b>组索引</b>,我们将高速缓存看成是一个关于组的移位数据,那么这些组索引位就是一个到这个数组的索引,例如下图中映射到组1</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228220503.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228220503.png" alt="image"></a></p></li></ol><ol start="2"><li>行匹配<p>上一步中已经选择了某个组,接下来就是确定这一组中是否存在A地址所在的缓存块,<b>在直接映射高速缓存中这很容易因为只有一行</b>.</p><p>首先判断<b>有效位必须为1</b>,如果没有设置有效位那么这个缓存块是没有意义的.接着<b>截取A地址中的标记t,与缓存块中的标记t判断</b>,如果相同则说明缓存命中.否则缓存不命中</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228220705.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228220705.png" alt="image"></a></p></li></ol><ol start="3"><li>字选择<p>最后一步就是根据b在缓存块B中找到对应的位置,这里的<b>b就是块偏移</b>,如上图所示</p><p>每个缓存行会缓存 B 个块, b 位地址可以索引对应的块, 对于不同的类型数据(char short int)只需要依次索引(1/2/4)个缓存块即可</p></li></ol><hr><p>我们这里假设有如下的一个高速缓存,(S,E,B,m)=(4,1,4,8),换句话说高速缓存有4个组(S),s=2,每个组一行(E=1),每个块两个字节(b=2),地址8位(m=8), 则该缓存的结构如下图所示</p><blockquote><p>计算可得 tag 位的长度 t = 8-2-2 = 4</p></blockquote><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119161850.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119161850.png" alt="20240119161850"></a></p><p>那么此时如果我们要读取地址 <code>0x00000101</code> 的 1 字节数据, 流程如下:</p><ol start="1"><li>划分地址, 找到 tag, set, offset 的部分, 根据 set index 找到对应的缓存组</li></ol><ol start="2"><li>判断 valid 有效位为 1, 说明其是一个有效的缓存块, 若为 0 则认为缓存失效</li></ol><ol start="3"><li>判断 tag <code>0000</code> 和该缓存行的 tag <code>0000</code> 是否相同, 如果相同则说明是相同的数据, 否则无效</li></ol><ol start="4"><li>取出数据</li></ol><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119162653.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119162653.png" alt="20240119162653"></a></p><p>但是我们发现对于另一个地址 <code>0x00100101</code> 地址来说, 其 set index 与 <code>0x00000101</code> 相同, 也会映射到这个组. 此时 <b>tag 不匹配发生缓存不命中, 需要再去内存中取数据, 然后使用新的数据更新缓存行</b>, 新的 tag 新的 data</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119163751.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119163751.png" alt="20240119163751"></a></p><h2 id="h2-3">组相联高速缓存</h2><p>直接映射高速缓存冲突不命中造成的问题源于<b>每个组只有一行</b>, 那么我们自然可以想到<b>每一个组设置多个缓存行</b>, 这就是组相联高速缓存</p><p>组选择和字选择阶段都没有变化,唯一的区别就是在行选择的阶段,由于有多行,所以进行有效位和标记位判断的时候需要扫描所有行</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230211.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230211.png" alt="image"></a></p><ol start="1"><li>通过 set index 找到对应的组</li></ol><ol start="2"><li>依次判断组内所有的缓存行, 如果 valid 且 tag 相同, 则取数据</li></ol><ol start="3"><li>否则发生缓存不命中, 去内存中找, 选择一个缓存行进行更新</li></ol><h2 id="h2-4">全相联高速缓存</h2><p>全相联是指所有的组全部连接在一起, 直接省去了 S 的部分, 全相联中S=1,只有唯一的一个组,此时E=C/B, 如下图所示</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230350.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230350.png" alt="image"></a></p><p>且因为S=1,所以s=0,所以地址被划分为标记位和偏移量</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230525.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230525.png" alt="image"></a></p><p>其他选择方式与组相联完全相同,甚至砍掉了<b>第一步的组选择, 直接搜索所有行</b></p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230534.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230534.png" alt="image"></a></p><p>因为高速缓存电路必须<b>并行的遍历所有行,匹配所有标记位</b>,所以构造一个又大又快的相联高速缓存困难且昂贵,因此<b>全相联高速缓存指适合做小的高速缓存, 例如虚拟内存中的快表TLB</b></p><h2 id="h2-5">高速缓存的写</h2><p>高速缓存的读比较容易,但是写的情况就要复杂很多了.</p><p>假设我们要写一个已经缓存了的字(写命中,write hit),在告诉缓存更新它的副本w之后应该如何更新w在层次结构中低一层的副本呢?</p><p>最简单的办法称为<b>写直达(write-through)</b>,就是立即<b>将w的高速缓存块写回到低一层中</b>,但是缺点是每次写回都会引起总线流量.</p><p>另一种办法称为<b>写回(write back)</b>,<b>尽可能地推迟更新,只有当替换算法要驱逐这个更新过的块时才把它写回到低一层中</b>. 由于局部性,写回能显著的减少总线流量,但是它的缺点是增加了复杂性,高速缓存必须为每个高速缓冲行<b>维护一个额外的修改位(dirty bit)</b>表明这个高速缓冲块是否被修改过</p><p>另一个问题就是如何处理写不命中(write miss),一种方法称为写分配(write allocate),加载相应的低一层的块到高速缓冲,然后更新这个高速缓冲块.但是缺点是每次不命中都会导致一个块从低一层传送到高速缓冲.</p><p>另一种方法称为非写分配(not write allocate),避开高速缓冲,直接把这个字写到低一层中</p><p>为写操作优化高速缓存是一个细致且困难的问题,这里不再展开</p><h2 id="h2-6">真实的高速缓存层次</h2><p>目前我们一直假设高速缓存中只保存程序数据,但事实上高速缓存除了保存数据也保存指令.保存指令的高速缓存称为i-cache,保存程序数据的高速缓存称为d-cache,既保存指令又保存数据的高速缓存称为统一的高速缓存</p><p>现代处理器包括独立的i-cache和d-cache,这样做有很多原因,有两个独立的高速缓存,处理器可以同时读一个指令字和一个数据字.i-cache通常是只读的,因此比较简单,并且可以针对不同的访问模式优化这两个高速缓存,可以有不同的块大小,相联度和容量</p><p>下图是Intel Core i7处理器的高速缓存层次,每个CPU芯片有四个核,每个核有自己私有的L1 i-cache L1 d-cache和L2统一高速缓存,所有核共享L3统一高速缓存,这里的一个有趣的特性是所有的SRAM高速缓存都在CPU芯片上</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228235118.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228235118.png" alt="image"></a></p><p>如今的处理器基本都是 3 级缓存结构, 如下图所示:</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118215340.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118215340.png" alt="20240118215340"></a></p><p>不同大小核的缓存大小也可能不相同</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118213517.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118213517.png" alt="20240118213517"></a></p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118213547.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118213547.png" alt="20240118213547"></a></p><p>可以直接使用如下指令查看当前系统的缓存大小</p><pre class="language-shell"><code><span class="Token VARIANT">$</span><span class="Token SPACE"> </span><span class="Token Program ID">lscpu</span><span class="Token LF">
</span><span class="Token Function Program ID">Caches</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token ID">sum</span><span class="Token SPACE"> </span><span class="Token ID">of</span><span class="Token SPACE"> </span><span class="Token ID">all</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token COLON">:</span><span class="Token LF">
</span><span class="Token SPACE">  </span><span class="Token Program ID">L1d:</span><span class="Token SPACE">                   </span><span class="Token NUMBER">384</span><span class="Token SPACE"> </span><span class="Token Function ID">KiB</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token NUMBER">8</span><span class="Token SPACE"> </span><span class="Token ID">instances</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token LF">
</span><span class="Token SPACE">  </span><span class="Token Program ID">L1i:</span><span class="Token SPACE">                   </span><span class="Token NUMBER">256</span><span class="Token SPACE"> </span><span class="Token Function ID">KiB</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token NUMBER">8</span><span class="Token SPACE"> </span><span class="Token ID">instances</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token LF">
</span><span class="Token SPACE">  </span><span class="Token Program ID">L2:</span><span class="Token SPACE">                    </span><span class="Token NUMBER">10</span><span class="Token SPACE"> </span><span class="Token Function ID">MiB</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token NUMBER">8</span><span class="Token SPACE"> </span><span class="Token ID">instances</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token LF">
</span><span class="Token SPACE">  </span><span class="Token Program ID">L3:</span><span class="Token SPACE">                    </span><span class="Token NUMBER">24</span><span class="Token SPACE"> </span><span class="Token Function ID">MiB</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token NUMBER">1</span><span class="Token SPACE"> </span><span class="Token ID">instance</span><span class="Token BraceDepth-0 RPAREN">)</span></code></pre><h2 id="h2-7">参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/668289721" target="_blank">天玑 9300 架构测试既 vivo X100 系列体验报告</a></li></ul><ul><li><a href="https://www.bilibili.com/video/BV1dQ4y1J7LC" target="_blank">天玑9300性能前瞻:发哥太强了!</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../code/python-riscv" >code</a><ul><li><a href="../../code/python-riscv" >python-riscv</a></li></ul><ul><li><a href="../../code/processor-controllor" >processor-controllor</a></li></ul><ul><li><a href="../../code/pipeline-profiling" >pipeline-profiling</a></li></ul><ul><li><a href="../../code/scoreboard" >scoreboard</a></li></ul><ul><li><a href="../../code/Tomasulo" >Tomasulo</a></li></ul><ul><li><a href="../../code/rob-tom" >rob-tom</a></li></ul><ul><li><a href="../../code/superscale" >superscale</a></li></ul></li></ul><ul><li><a href="../../notes/cache" >notes</a><ul><li><a href="../../notes/cache" >cache</a></li></ul><ul><li><a href="../../notes/cache-coherance" >cache-coherance</a></li></ul></li></ul><ul><li><a href="../../read/lecture1" >read</a><ul><li><a href="../../read/lecture1" >lecture1</a></li></ul><ul><li><a href="../../read/lecture2" >lecture2</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../code/superscale","../../notes/cache-coherance","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>