<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    <link rel='stylesheet' href=../../../css/python.css /><link rel='stylesheet' href=../../../css/riscvasm.css /><link rel='stylesheet' href=../../../css/shell.css /><link rel='stylesheet' href=../../../css/txt.css />
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/luzhixing12345/archlab.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">cache</a><ul><li><a href="#h2-1">缓存组织结构</a></li></ul><ul><li><a href="#h2-2">缓存分类</a><ul><li><a href="#h3-3">直接映射高速缓存</a></li></ul><ul><li><a href="#h3-4">组相联高速缓存</a></li></ul><ul><li><a href="#h3-5">全相联高速缓存</a></li></ul><ul><li><a href="#h3-6">地址访问</a></li></ul></li></ul><ul><li><a href="#h2-7">高速缓存的写</a></li></ul><ul><li><a href="#h2-8">真实的高速缓存层次</a></li></ul><ul><li><a href="#h2-9">参考</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">cache</h1><p>计算机软件设计者和计算机用户希望存储器的容量越大越好,速度越快越好,价格越便宜越好.但事实上&quot;容量大、速度快、价格低&quot;的3个要求是相互制约的.我们的解决的办法就是采用多种存储器构成存储器结构层次, 从高层向低层,存储设备变得越来越慢,但同时也变得更大更便宜.</p><p>下图是一个经典的计算机存储器结构层次</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228203220.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228203220.png" alt="image"></a></p><p>早期计算机系统的存储器层次只有三层,CPU寄存器,DRAM主存储器,磁盘存储.由于CPU和主存之间的频率逐渐增大,由于内存DRAM本身这种存储介质的物理特性的延迟,一条由 CPU 发出的访存指令如果真的要去内存中读写数据实际上需要很多个时钟周期才可以完成</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240224104307.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240224104307.png" alt="20240224104307"></a></p><p>因此系统设计者被迫在CPU寄存器文件和主存之间插入了一个小的SRAM高速缓存,被称为L1高速缓存(一级缓存), 同时我们可以利用程序的时空局部性采用一些预取策略提前将数据和指令读到缓存中, 这样如果CPU可以在更快的缓存中读到数据就不需要再去访问更慢的内存了,也就进而提高了性能</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240224104219.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240224104219.png" alt="20240224104219"></a></p><p>两级存储器之间有四个基本的问题</p><ol start="1"><li><b>映像规则</b>: 当把一个块调入高一层存储器时, 可以放到哪些位置上?</li></ol><ol start="2"><li><b>查找方法</b>: 当所要访问的块在高一层存储器中时, 如何找到该块?</li></ol><ol start="3"><li><b>替换算法</b>: 当发生失效时, 应该替换哪一块?</li></ol><ol start="4"><li><b>写策略</b>: 当进行写访问时, 应进行哪些操作?</li></ol><p>下面我们围绕这四个问题来逐一解答一下</p><h2 id="h2-1">缓存组织结构</h2><p>一般而言,高速缓存的结构可以用元组(S,E,B,m)来描述, S指一共有S个高速缓存组,每组E行,每一行中有效的缓存块的个数为B, m为主存物理地址长度(通常为64). 组织结构如下图所示:</p><blockquote><p>每一个缓存块的大小都是 1 byte, 缓存块的个数 B 和 S 都是 2 的幂次, 即 <code>S = 2^s</code>, <code>B = 2^b</code>.</p></blockquote><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119110922.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119110922.png" alt="20240119110922"></a></p><p>缓存总大小为 <code>B x E x S</code> 字节, 即图中灰色部分.</p><p>每一个缓存行除了缓存块还有 1 位有效位, 用于表示这个行是否包含有意义的信息; 以及 t 位标记位.</p><p>对于一个虚拟地址, 其在缓存中的地址会被划分成如下格式.</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119114604.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119114604.png" alt="20240119114604"></a></p><p>高速缓存一共S组,<b>一共需要s位(2^s=S)来对应每一组</b>, 每一行是一个高速缓存行.其中每一行有1位有效位,t位标记位,和B字节的缓存块大小, 因为计算机的地址长度m是确定的(一般32或者64),<b>B字节大小的缓存块需要b位的偏移量来表示(2^b=B)</b>, 这里的t是计算出来的, 组索引占用s位, 每一个缓存块索引占 b 位, 所以 <code>t = m-b-s</code>, 即<b>剩余部分都留作 tag 位</b></p><blockquote><p>Cache本质就是一个硬件hash表(Tag RAM)+SRAM(DATA RAM)</p></blockquote><h2 id="h2-2">缓存分类</h2><h3 id="h3-3">直接映射高速缓存</h3><p>每个组只有一行(E=1)的高速缓存被称为直接映射高速缓存,这种情况是最容易实现和理解的</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228220428.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228220428.png" alt="image"></a></p><p>现在一条加载指令指示CPU从主存地址A中读取一个字,那么此时<b>高速缓存如何判断此时缓存中是否保存着A地址处那个字的副本呢?</b></p><p>这个过程被分为三个部分: 组选择 + 行匹配 + 字选择</p><ol start="1"><li>组选择<p>给定地址A,我们可以根据之前计算的t,s,b的数据截取其中s的部分,这是<b>组索引</b>,我们将高速缓存看成是一个关于组的移位数据,那么这些组索引位就是一个到这个数组的索引,例如下图中映射到组1</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228220503.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228220503.png" alt="image"></a></p></li></ol><ol start="2"><li>行匹配<p>上一步中已经选择了某个组,接下来就是确定这一组中是否存在A地址所在的缓存块,<b>在直接映射高速缓存中这很容易因为只有一行</b>.</p><p>首先判断<b>有效位必须为1</b>,如果没有设置有效位那么这个缓存块是没有意义的.接着<b>截取A地址中的标记t,与缓存块中的标记t判断</b>,如果相同则说明缓存命中.否则缓存不命中</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228220705.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228220705.png" alt="image"></a></p></li></ol><ol start="3"><li>字选择<p>最后一步就是根据b在缓存块B中找到对应的位置,这里的<b>b就是块偏移</b>,如上图所示</p><p>每个缓存行会缓存 B 个块, b 位地址可以索引对应的块, 对于不同的类型数据(char short int)只需要依次索引(1/2/4)个缓存块即可</p></li></ol><hr><p>我们这里假设有如下的一个高速缓存,(S,E,B,m)=(4,1,4,8),换句话说高速缓存有4个组(S),s=2,每个组一行(E=1),每个块两个字节(b=2),地址8位(m=8), 则该缓存的结构如下图所示</p><blockquote><p>计算可得 tag 位的长度 t = 8-2-2 = 4</p></blockquote><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119161850.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119161850.png" alt="20240119161850"></a></p><p>那么此时如果我们要读取地址 <code>0x00000101</code> 的 1 字节数据, 流程如下:</p><ol start="1"><li>划分地址, 找到 tag, set, offset 的部分, 根据 set index 找到对应的缓存组</li></ol><ol start="2"><li>判断 valid 有效位为 1, 说明其是一个有效的缓存块, 若为 0 则认为缓存失效</li></ol><ol start="3"><li>判断 tag <code>0000</code> 和该缓存行的 tag <code>0000</code> 是否相同, 如果相同则说明是相同的数据, 否则无效</li></ol><ol start="4"><li>取出数据</li></ol><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119162653.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119162653.png" alt="20240119162653"></a></p><p>但是我们发现对于另一个地址 <code>0x00100101</code> 地址来说, 其 set index 与 <code>0x00000101</code> 相同, 也会映射到这个组. 此时 <b>tag 不匹配发生缓存不命中, 需要再去内存中取数据, 然后使用新的数据更新缓存行</b>, 新的 tag 新的 data</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119163751.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240119163751.png" alt="20240119163751"></a></p><p>那这种时候如果上一个地址又来取数据了那么又会造成一次 cache miss, 频繁的替换 cache, 相当于每次访问数据都要从主存中读取, 这种现象叫做 cache 颠簸(cache thrashing)</p><h3 id="h3-4">组相联高速缓存</h3><p>直接映射高速缓存冲突不命中造成的问题源于<b>每个组只有一行</b>, 那么我们自然可以想到<b>每一个组设置多个缓存行</b>, 这就是组相联高速缓存</p><p>组选择和字选择阶段都没有变化,唯一的区别就是在行选择的阶段,由于有多行,所以进行有效位和标记位判断的时候需要扫描所有行</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230211.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230211.png" alt="image"></a></p><ol start="1"><li>通过 set index 找到对应的组</li></ol><ol start="2"><li>依次判断组内所有的缓存行, 如果 valid 且 tag 相同, 则取数据</li></ol><ol start="3"><li>否则发生缓存不命中, 去内存中找, 选择一个缓存行进行更新</li></ol><p>这也是 cache 最常用的实现方式</p><h3 id="h3-5">全相联高速缓存</h3><p>全相联是指所有的组全部连接在一起, 直接省去了 S 的部分, 全相联中S=1,只有唯一的一个组,此时E=C/B, 如下图所示</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230350.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230350.png" alt="image"></a></p><p>且因为S=1,所以s=0,所以地址被划分为标记位和偏移量</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230525.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230525.png" alt="image"></a></p><p>其他选择方式与组相联完全相同,甚至砍掉了<b>第一步的组选择, 直接搜索所有行</b></p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230534.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228230534.png" alt="image"></a></p><p>因为高速缓存电路必须<b>并行的遍历所有行,匹配所有标记位</b>,所以构造一个又大又快的相联高速缓存困难且昂贵,因此<b>全相联高速缓存指适合做小的高速缓存, 例如虚拟内存中的快表TLB</b></p><h3 id="h3-6">地址访问</h3><p>处理器在进行存储器访问时,处理器访问的地址是虚拟地址,经过MMU的转换,得到物理地址.那么查询cache组是用虚拟地址还是物理地址的Index域呢?当找到cache组时,使用虚拟地址,还是物理地址的Tag域来匹配cache line呢?</p><p>有如下三种策略:</p><ul><li><b>VIVT</b>(Virtual Index Virtual Tag):使用虚拟地址Index域和虚拟地址Tag域</li></ul><ul><li><b>VIPT</b>(Virtual Index Physical Tag):使用虚拟地址Index域和物理地址Tag域</li></ul><ul><li><b>PIPT</b>(Physical Index Physical Tag):使用物理地址Index域和物理地址Tag域</li></ul><p>VIVT/VIPT/PIPT的优缺点分析:</p><ul><li>VIVT:多个VA可能映射到同一PA,导致多个cache line组(VA不同,index域不同,查找到的cache 组则不同)映射到同一物理地址,这种现象叫做cache alias(高速缓存别名).一旦一个VA到PA的映射关系改变,cache内容将会写回物理内存.此时,由于物理内存内容的变化需要同步到cache,就需要clean和invalidate(这两个操作结合起来就叫做flush)其余同名cache line,导致系统性能下降.</li></ul><ul><li>VIPT:如果index域位于地址的bit0~bit11(因为linux kernel以4KB(12bit位宽)大小为页面进行物理内存管理),就不会引起cache alias,否则还是会引起该问题.因为对于一个页面来说,虚拟地址和物理地址的低12bit是完全一样的,如果index域位于bit0~bit11,此时VIPT等价于PIPT.</li></ul><ul><li>PIPT:就不会存在cache alias问题,但是结构更复杂.ARM Cortex-A系列处理器使用的是PIPT方式.</li></ul><h2 id="h2-7">高速缓存的写</h2><p>高速缓存的读比较容易,但是写的情况就要复杂很多了.</p><p>假设我们要写一个已经缓存了的字(写命中,write hit),在告诉缓存更新它的副本w之后应该如何更新w在层次结构中低一层的副本呢?</p><p>最简单的办法称为<b>写直达(write-through)</b>,就是立即<b>将w的高速缓存块写回到低一层中</b>,但是缺点是每次写回都会引起总线流量.</p><p>另一种办法称为<b>写回(write back)</b>,<b>尽可能地推迟更新,只有当替换算法要驱逐这个更新过的块时才把它写回到低一层中</b>. 由于局部性,写回能显著的减少总线流量,但是它的缺点是增加了复杂性,高速缓存必须为每个高速缓冲行<b>维护一个额外的修改位(dirty bit)</b>表明这个高速缓冲块是否被修改过</p><p>另一个问题就是如何处理写不命中(write miss),一种方法称为写分配(write allocate),加载相应的低一层的块到高速缓冲,然后更新这个高速缓冲块.但是缺点是每次不命中都会导致一个块从低一层传送到高速缓冲.</p><p>另一种方法称为非写分配(not write allocate),避开高速缓冲,直接把这个字写到低一层中</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240221111201.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240221111201.png" alt="20240221111201"></a></p><h2 id="h2-8">真实的高速缓存层次</h2><p>目前我们一直假设高速缓存中只保存程序数据,但事实上高速缓存除了保存数据也保存指令.保存指令的高速缓存称为i-cache,保存程序数据的高速缓存称为d-cache,既保存指令又保存数据的高速缓存称为统一的高速缓存</p><p>现代处理器包括独立的i-cache和d-cache,这样做有很多原因,有两个独立的高速缓存,处理器可以同时读一个指令字和一个数据字.i-cache通常是只读的,因此比较简单,并且可以针对不同的访问模式优化这两个高速缓存,可以有不同的块大小,相联度和容量</p><p>下图是Intel Core i7处理器的高速缓存层次,每个CPU芯片有四个核,每个核有自己私有的L1 i-cache L1 d-cache和L2统一高速缓存,所有核共享L3统一高速缓存,这里的一个有趣的特性是所有的SRAM高速缓存都在CPU芯片上</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228235118.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20221228235118.png" alt="image"></a></p><p>现在的处理器一般是有三级缓存,每个核心上有两级缓存,然后所有核心共享一个大的L3缓存,L1还额外按功能划分为指令的缓存和数据的缓存</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118215340.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118215340.png" alt="20240118215340"></a></p><p>不同大小核的缓存大小也可能不相同</p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118213517.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118213517.png" alt="20240118213517"></a></p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118213547.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118213547.png" alt="20240118213547"></a></p><p><a data-lightbox="example-1" href="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118213343.png"><img src="https://raw.githubusercontent.com/learner-lu/picbed/master/20240118213343.png" alt="20240118213343"></a></p><p>可以直接使用如下指令查看当前系统的缓存大小</p><pre class="language-shell"><code><span class="Token VARIANT">$</span><span class="Token SPACE"> </span><span class="Token Program ID">lscpu</span><span class="Token LF">
</span><span class="Token Function Program ID">Caches</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token ID">sum</span><span class="Token SPACE"> </span><span class="Token ID">of</span><span class="Token SPACE"> </span><span class="Token ID">all</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token COLON">:</span><span class="Token LF">
</span><span class="Token SPACE">  </span><span class="Token Program ID">L1d:</span><span class="Token SPACE">                   </span><span class="Token NUMBER">384</span><span class="Token SPACE"> </span><span class="Token Function ID">KiB</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token NUMBER">8</span><span class="Token SPACE"> </span><span class="Token ID">instances</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token LF">
</span><span class="Token SPACE">  </span><span class="Token Program ID">L1i:</span><span class="Token SPACE">                   </span><span class="Token NUMBER">256</span><span class="Token SPACE"> </span><span class="Token Function ID">KiB</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token NUMBER">8</span><span class="Token SPACE"> </span><span class="Token ID">instances</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token LF">
</span><span class="Token SPACE">  </span><span class="Token Program ID">L2:</span><span class="Token SPACE">                    </span><span class="Token NUMBER">10</span><span class="Token SPACE"> </span><span class="Token Function ID">MiB</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token NUMBER">8</span><span class="Token SPACE"> </span><span class="Token ID">instances</span><span class="Token BraceDepth-0 RPAREN">)</span><span class="Token LF">
</span><span class="Token SPACE">  </span><span class="Token Program ID">L3:</span><span class="Token SPACE">                    </span><span class="Token NUMBER">24</span><span class="Token SPACE"> </span><span class="Token Function ID">MiB</span><span class="Token SPACE"> </span><span class="Token BraceDepth-0 LPAREN">(</span><span class="Token NUMBER">1</span><span class="Token SPACE"> </span><span class="Token ID">instance</span><span class="Token BraceDepth-0 RPAREN">)</span></code></pre><h2 id="h2-9">参考</h2><ul><li><a href="https://www.cnblogs.com/DF11G/p/17214206.html" target="_blank">Cache知识记录</a></li></ul><ul><li><a href="https://www.cnblogs.com/jianhua1992/p/16852781.html" target="_blank">Cache的相关知识(二)</a></li></ul><ul><li><a href="https://www.cnblogs.com/gujiangtaoFuture/articles/11163844.html" target="_blank">Cache Line操作和Cache相关概念介绍</a></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/668289721" target="_blank">天玑 9300 架构测试既 vivo X100 系列体验报告</a></li></ul><ul><li><a href="https://www.bilibili.com/video/BV1dQ4y1J7LC" target="_blank">天玑9300性能前瞻:发哥太强了!</a></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../code/python-riscv" >code</a><ul><li><a href="../../code/python-riscv" >python-riscv</a></li></ul><ul><li><a href="../../code/processor-controllor" >processor-controllor</a></li></ul><ul><li><a href="../../code/pipeline-profiling" >pipeline-profiling</a></li></ul><ul><li><a href="../../code/scoreboard" >scoreboard</a></li></ul><ul><li><a href="../../code/Tomasulo" >Tomasulo</a></li></ul><ul><li><a href="../../code/rob-tom" >rob-tom</a></li></ul><ul><li><a href="../../code/superscale" >superscale</a></li></ul></li></ul><ul><li><a href="../../read/lecture1" >read</a><ul><li><a href="../../read/lecture1" >lecture1</a></li></ul><ul><li><a href="../../read/lecture2" >lecture2</a></li></ul><ul><li><a href="../../read/cache" >cache</a></li></ul><ul><li><a href="../../read/cache-coherence" >cache-coherence</a></li></ul></li></ul><ul><li><a href="../../lab/lab1" >lab</a><ul><li><a href="../../lab/lab1" >lab1</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../read/lecture2","../../read/cache-coherence","ab")</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png")</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/before_copy.png","../../../img/after_copy.png")</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>