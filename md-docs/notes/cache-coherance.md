
# cache-coherance

人们发现使用大型的多级缓存可以充分降低处理器对于存储器带宽的需求, 但是缓存策略总是伴随着数据一致性的问题,通俗的讲是**不同存储节点中同一条数据副本之间不一致的问题**.CPU Cache的存在导致多核CPU中缓存数据与内存数据之间可能存在不一致的情况.

首先思考单核CPU下,何时将缓存数据的修改同步至内存中,使得缓存与内存数据一致?

- **写直达**:CPU每次访问修改数据时,无论数据在不在缓存中,都将修改后的数据同步到内存中,缓存数据与内存数据保持强一致性,这种做法影响写操作的性能.
- **写回**:为了避免每次写操作都要进行数据同步带来的性能损失,写回策略里发生读写操作时:
  - 如果缓存行中命中了数据,写操作对缓存行中数据进行更新,并标记该缓存行为已修改.
  - 如果缓存中未命中数据,且数据所对应的缓存行中存放了其他数据:
    - **若该缓存行被标记为已修改**,读写操作都会将缓存行中现存的数据写回内存中,再将当前要获取的数据从内存读到缓存行,写操作对数据进行更新后标记该缓存行为已修改;
    - **若该缓存行未被标记为已修改**,读写操作都直接将当前要获取的数据从内存读到缓存行.写操作对数据进行更新后标记该缓存行为已修改.

## 缓存一致性问题

假设 CPU1 和 CPU2 同时运行两个线程,都操作共同的变量 a 和 b, 为了考虑性能,使用了我们前面所说的**写回**策略, 把执行结果直接写入到 L1/L2 Cache 中,然后把 L1/L2 Cache 中对应的 Block 标记为脏的,这个时候**数据其实没有被同步到内存**中的,因为写回策略只有在 A 号核心中的这个 Cache Block 要被替换的时候,数据才会写入到内存里.

![20240120203920](https://raw.githubusercontent.com/learner-lu/picbed/master/20240120203920.png)

由于 CPU 1/2 的缓存策略, 导致数据在这个时候是不一致,从而可能会导致执行结果的错误.

那么,要解决这一问题,就需要一种机制,来**同步两个不同核心里面的缓存数据**.要实现的这个机制的话,要保证做到下面这 2 点:

1. 某个 CPU 核心里的 Cache 数据更新时,必须要传播到其他核心的 Cache, 称为**写传播**(Write Propagation);
2. 某个 CPU 核心里对数据的操作顺序,必须在其他核心看起来顺序是一样的, 称为**事务的串形化**(Transaction Serialization).

第一点写传播很容易就理解,当某个核心在 Cache 更新了数据,就需要同步到其他核心的 Cache 里; 第二点事务的串行化指的是不同 CPU 要看到**相同顺序的数据变化**,比如两个线程同时执行 `a=100` 和 `a=200`, 所有其他核心收到的更新变化都应该是相同的, 比如变量 a 都是先变成 100,再变成 200

![20240120210511](https://raw.githubusercontent.com/learner-lu/picbed/master/20240120210511.png)

要实现事务串形化,要做到 2 点:

- CPU 核心对于 Cache 中数据的操作,需要**同步给其他 CPU 核心**;
- 要引入「**锁**」的概念,如果两个 CPU 核心里有相同数据的 Cache,那么对于这个 Cache 数据的更新,只有拿到了「锁」,才能进行对应的数据更新.

## 缓存一致性

在讨论缓存一致性问题的解决方案之前我们先来看一下**一致性的内存系统**的定义: **所有处理器在任何时刻对每一个内存位置的最后一个全局写入值有一个一致的视图**

> all processors, at any time, have consistent view of last globally written value to each location


### 总线嗅探

写传播的原则就是当某个 CPU 核心更新了 Cache 中的数据,要把该事件广播通知到其他核心.最常见实现的方式是**总线嗅探(Bus Snooping)**.

当任何一个 CPU 核心修改了 L1 Cache 中变量的值, 都会通过总线把这个事件广播通知给其他所有的核心. 每个 CPU 核心都会监听总线上的广播事件,并检查是否有相同的数据在自己的 L1 Cache 里面,如果其他 CPU 核心的 L1 Cache 中有该数据,那么也需要把该数据更新到自己的 L1 Cache.

总线嗅探方法很简单, CPU 需要每时每刻监听总线上的一切活动,但是不管别的核心的 Cache 是否缓存相同的数据,都需要发出一个广播事件,这无疑会**加重总线的负载**.

另外,总线嗅探只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道,但是**并不能保证事务串形化**.

于是,有一个协议基于总线嗅探机制实现了事务串形化,也用状态机机制降低了总线带宽压力,这个协议就是 MESI 协议

## MESI协议

MESI首先规定了缓存行(cache line)的四种状态, 可以用 2 bits 来区分:

- `Modified`: 已修改, 指数据被修改后保存在 cache line 中, 和内存中的数据不一致, 数据只存在于本 cache line 中
- `Exclusive`: 独占, 指数据和内存中的数据一致, 数据只存在于本 cache line 中
- `Shared`: 共享, 指数据和内存中的数据一致, 数据存在于很多 cache 中
- `Invalidated`: 已失效, 指该 cache line 无效

## 参考

- [一小时,完全搞懂 cpu 缓存一致性](https://zhuanlan.zhihu.com/p/651732241)
- [无锁编程_从CPU缓存一致性讲到内存模型](https://zhuanlan.zhihu.com/p/642416997)
- [在线体验 MESI 协议状态转换](https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESIHelp.htm)
- [MESI保证了缓存一致性,那么为什么多线程 i++还会有问题?的回答](https://www.zhihu.com/question/619301632/answer/3184265150)
- [MESI and MOESI Protocols](https://www.youtube.com/watch?v=nrzT044qNIc)